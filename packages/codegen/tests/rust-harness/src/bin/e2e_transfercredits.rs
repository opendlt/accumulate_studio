//! TransferCredits E2E
//! ===================
//!
//! Generated by Accumulate Studio
//! Network: kermit

use accumulate_client::{
    AccumulateClient, AccOptions, SmartSigner, TxBody,
    derive_lite_identity_url, derive_lite_token_account_url,
};
use sha2::{Digest, Sha256};
use url::Url;
use serde_json::{json, Value};

const NETWORK_V2: &str = "https://kermit.accumulatenetwork.io/v2";
const NETWORK_V3: &str = "https://kermit.accumulatenetwork.io/v3";

fn sha256_hash(data: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hex::encode(hasher.finalize())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    //
    // TransferCredits E2E
    // E2E test for TransferCredits
    // Generated by Accumulate Studio
    //

    // Connect to network (override with env vars for testing)
    let v2 = std::env::var("ACCUMULATE_V2_URL").unwrap_or_else(|_| NETWORK_V2.to_string());
    let v3 = std::env::var("ACCUMULATE_V3_URL").unwrap_or_else(|_| NETWORK_V3.to_string());
    let client = AccumulateClient::new_with_options(
        Url::parse(&v2)?, Url::parse(&v3)?, AccOptions::default()
    ).await?;

    let mut tx_ids: Vec<(&str, String)> = Vec::new();


    // =========================================================
    // GenerateKeys (Action: GenerateKeys)
    // =========================================================
    let generatekeys_signer = AccumulateClient::generate_keypair();
    let generatekeys_pub_key = generatekeys_signer.verifying_key().to_bytes();
    let generatekeys_pub_hash = sha256_hash(&generatekeys_pub_key);
    let generatekeys_lid = derive_lite_identity_url(&generatekeys_pub_key);
    let generatekeys_lta = derive_lite_token_account_url(&generatekeys_pub_key);
    println!("Generated keypair:");
    println!("  Lite Identity: {}", generatekeys_lid);
    println!("  Lite Token Account: {}", generatekeys_lta);
    println!("  Public Key Hash: {}", &generatekeys_pub_hash[..32]);

    // =========================================================
    // Faucet (Action: Faucet)
    // =========================================================
    println!("Requesting tokens from faucet...");
    let faucet_faucet_url = generatekeys_lta.to_string();
    for _i in 0..1 {
        let faucet_faucet_params = json!({ "account": faucet_faucet_url });
        match client.v3_client.call_v3::<Value>("faucet", faucet_faucet_params).await {
            Ok(response) => {
                let txid = response.get("transactionHash")
                    .or_else(|| response.get("txid"))
                    .and_then(|v| v.as_str())
                    .unwrap_or("submitted");
                println!("  Faucet: {}", txid);
            }
            Err(e) => {
                println!("  Faucet failed: {}", e);
            }
        }
        tokio::time::sleep(std::time::Duration::from_secs(2)).await;
    }
    println!("Faucet request completed");

    // =========================================================
    // WaitForBalance (Action: WaitForBalance)
    // =========================================================
    println!("Waiting for balance...");
    let waitforbalance_scope = generatekeys_lta.to_string();
    let waitforbalance_min_bal: u64 = "10000000".replace('.', "").parse().unwrap_or(10000000);
    for waitforbalance_i in 0..30u32 {
        let waitforbalance_params = json!({ "scope": waitforbalance_scope, "query": { "queryType": "default" } });
        if let Ok(waitforbalance_acct) = client.v3_client.call_v3::<Value>("query", waitforbalance_params).await {
            if let Some(bal) = waitforbalance_acct.get("account").and_then(|a| a.get("balance")).and_then(|b| b.as_str()) {
                if bal.parse::<u64>().unwrap_or(0) >= waitforbalance_min_bal { break; }
            }
        } else {
            println!("  Account not found yet... (attempt {}/30)", waitforbalance_i + 1);
        }
        tokio::time::sleep(std::time::Duration::from_secs(2)).await;
    }
    println!("Balance reached");

    // =========================================================
    // AddCredits (Action: AddCredits)
    // =========================================================
    let addcredits_oracle: Value = client.v3_client.call_v3("network-status", json!({})).await
        .unwrap_or_else(|_| json!({}));
    let addcredits_price = addcredits_oracle.get("oracle")
        .and_then(|o| o.get("price"))
        .and_then(|p| p.as_u64())
        .unwrap_or(50000000);
    let mut addcredits_signer = SmartSigner::new(&client, generatekeys_signer.clone(), &generatekeys_lid);
    let addcredits_result = addcredits_signer.sign_submit_and_wait(
        &generatekeys_lta,
        &TxBody::add_credits(&generatekeys_lid, "2000000", addcredits_price),
        Some("Add credits"),
        30,
    ).await;
    if addcredits_result.success {
        println!("AddCredits SUCCESS - TxID: {:?}", addcredits_result.txid);
        if let Some(ref txid) = addcredits_result.txid {
            tx_ids.push(("AddCredits", txid.clone()));
        }
    } else {
        println!("AddCredits FAILED: {:?}", addcredits_result.error);
    }

    // =========================================================
    // WaitForCredits (Action: WaitForCredits)
    // =========================================================
    println!("Waiting for credits...");
    let waitforcredits_scope = generatekeys_lid.to_string();
    let waitforcredits_min_cred: u64 = 100;
    for waitforcredits_i in 0..30u32 {
        let waitforcredits_params = json!({ "scope": waitforcredits_scope, "query": { "queryType": "default" } });
        if let Ok(waitforcredits_acct) = client.v3_client.call_v3::<Value>("query", waitforcredits_params).await {
            if let Some(cred) = waitforcredits_acct.get("account").and_then(|a| a.get("creditBalance")).and_then(|c| c.as_u64()) {
                if cred >= waitforcredits_min_cred { break; }
            }
        } else {
            println!("  Account not found yet... (attempt {}/30)", waitforcredits_i + 1);
        }
        tokio::time::sleep(std::time::Duration::from_secs(2)).await;
    }
    println!("Credits reached");

    // =========================================================
    // CreateIdentity (Action: CreateIdentity)
    // =========================================================
    let mut createidentity_signer = SmartSigner::new(&client, generatekeys_signer.clone(), &generatekeys_lid);
    let createidentity_result = createidentity_signer.sign_submit_and_wait(
        &generatekeys_lta,
        &TxBody::create_identity("acc://e2e-33d2ab9a.acme", "acc://e2e-33d2ab9a.acme/book", &generatekeys_pub_hash),
        Some("Create ADI"),
        30,
    ).await;
    if createidentity_result.success {
        println!("CreateIdentity SUCCESS - TxID: {:?}", createidentity_result.txid);
        if let Some(ref txid) = createidentity_result.txid {
            tx_ids.push(("CreateIdentity", txid.clone()));
        }
    } else {
        println!("CreateIdentity FAILED: {:?}", createidentity_result.error);
    }

    // =========================================================
    // AddCredits_2 (Action: AddCredits)
    // =========================================================
    let addcredits_2_oracle: Value = client.v3_client.call_v3("network-status", json!({})).await
        .unwrap_or_else(|_| json!({}));
    let addcredits_2_price = addcredits_2_oracle.get("oracle")
        .and_then(|o| o.get("price"))
        .and_then(|p| p.as_u64())
        .unwrap_or(50000000);
    let mut addcredits_2_signer = SmartSigner::new(&client, generatekeys_signer.clone(), &generatekeys_lid);
    let addcredits_2_result = addcredits_2_signer.sign_submit_and_wait(
        &generatekeys_lta,
        &TxBody::add_credits(&generatekeys_lid, "5000000", addcredits_2_price),
        Some("Add credits"),
        30,
    ).await;
    if addcredits_2_result.success {
        println!("AddCredits SUCCESS - TxID: {:?}", addcredits_2_result.txid);
        if let Some(ref txid) = addcredits_2_result.txid {
            tx_ids.push(("AddCredits", txid.clone()));
        }
    } else {
        println!("AddCredits FAILED: {:?}", addcredits_2_result.error);
    }

    // =========================================================
    // WaitForCredits_2 (Action: WaitForCredits)
    // =========================================================
    println!("Waiting for credits...");
    let waitforcredits_2_scope = generatekeys_lid.to_string();
    let waitforcredits_2_min_cred: u64 = 100;
    for waitforcredits_2_i in 0..30u32 {
        let waitforcredits_2_params = json!({ "scope": waitforcredits_2_scope, "query": { "queryType": "default" } });
        if let Ok(waitforcredits_2_acct) = client.v3_client.call_v3::<Value>("query", waitforcredits_2_params).await {
            if let Some(cred) = waitforcredits_2_acct.get("account").and_then(|a| a.get("creditBalance")).and_then(|c| c.as_u64()) {
                if cred >= waitforcredits_2_min_cred { break; }
            }
        } else {
            println!("  Account not found yet... (attempt {}/30)", waitforcredits_2_i + 1);
        }
        tokio::time::sleep(std::time::Duration::from_secs(2)).await;
    }
    println!("Credits reached");

    // =========================================================
    // CreateKeyPage (Action: CreateKeyPage)
    // =========================================================
    let mut createkeypage_signer = SmartSigner::new(&client, generatekeys_signer.clone(), &generatekeys_lid);
    let createkeypage_key_0 = hex::decode("deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef").unwrap_or_default();
    let createkeypage_key_refs: Vec<&[u8]> = vec![
        &createkeypage_key_0,
    ];
    let createkeypage_result = createkeypage_signer.sign_submit_and_wait(
        "acc://e2e-33d2ab9a.acme/book",
        &TxBody::create_key_page(&createkeypage_key_refs),
        Some("Create key page"),
        30,
    ).await;
    if createkeypage_result.success {
        println!("CreateKeyPage SUCCESS - TxID: {:?}", createkeypage_result.txid);
        if let Some(ref txid) = createkeypage_result.txid {
            tx_ids.push(("CreateKeyPage", txid.clone()));
        }
    } else {
        println!("CreateKeyPage FAILED: {:?}", createkeypage_result.error);
    }

    // =========================================================
    // TransferCredits (Action: TransferCredits)
    // =========================================================
    let mut transfercredits_signer = SmartSigner::new(&client, generatekeys_signer.clone(), &generatekeys_lid);
    let transfercredits_result = transfercredits_signer.sign_submit_and_wait(
        "acc://e2e-33d2ab9a.acme/book/1",
        &TxBody::transfer_credits("acc://e2e-33d2ab9a.acme/book/1", 100),
        Some("Transfer credits"),
        30,
    ).await;
    if transfercredits_result.success {
        println!("TransferCredits SUCCESS - TxID: {:?}", transfercredits_result.txid);
        if let Some(ref txid) = transfercredits_result.txid {
            tx_ids.push(("TransferCredits", txid.clone()));
        }
    } else {
        println!("TransferCredits FAILED: {:?}", transfercredits_result.error);
    }

    // =========================================================
    // Transaction Summary
    // =========================================================
    println!("\n========== Transaction Summary ==========");
    for (label, txid) in &tx_ids {
        println!("  {}: {}", label, txid);
    }
    println!("Flow completed successfully!");
    Ok(())
}
