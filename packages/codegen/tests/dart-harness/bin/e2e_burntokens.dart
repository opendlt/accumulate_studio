/// BurnTokens E2E
/// Generated by Accumulate Studio
/// Network: kermit

import 'dart:async';
import 'dart:io';
import 'dart:typed_data';
import 'package:crypto/crypto.dart';
import 'package:opendlt_accumulate/opendlt_accumulate.dart';

const String defaultV2 = 'https://kermit.accumulatenetwork.io/v2';
const String defaultV3 = 'https://kermit.accumulatenetwork.io/v3';

String toHexString(List<int> bytes) {
  return bytes.map((b) => b.toRadixString(16).padLeft(2, '0')).join();
}

Future<void> main() async {
  final v2 = Platform.environment['ACCUMULATE_V2_URL'] ?? defaultV2;
  final v3 = Platform.environment['ACCUMULATE_V3_URL'] ?? defaultV3;
  final client = Accumulate.custom(v2Endpoint: v2, v3Endpoint: v3);
  final txIds = <MapEntry<String, String>>[];
  try {


    // =========================================================
    // GenerateKeys (GenerateKeys)
    // =========================================================
    final generatekeysKp = await Ed25519KeyPair.generate();
    final generatekeysKey = UnifiedKeyPair.fromEd25519(generatekeysKp);
    final generatekeysLid = await generatekeysKp.deriveLiteIdentityUrl();
    final generatekeysLta = await generatekeysKp.deriveLiteTokenAccountUrl();
    final generatekeysPubKey = await generatekeysKp.publicKeyBytes();
    final generatekeysPubHash = toHexString(sha256.convert(generatekeysPubKey).bytes);
    print('Generated keypair:');
    print('  Lite Identity: ${generatekeysLid}');
    print('  Lite Token Account: ${generatekeysLta}');
    print('  Public Key Hash: ${generatekeysPubHash}');


    // =========================================================
    // Faucet (Faucet)
    // =========================================================
    print('Requesting tokens from faucet...');
    for (var i = 0; i < 1; i++) {
      try {
        final resp = await client.v2.faucet({
          'type': 'acmeFaucet',
          'url': generatekeysLta.toString(),
        });
        print('  Faucet ${i + 1}/1: ${resp["txid"]}');
      } catch (e) {
        print('  Faucet ${i + 1}/1 failed: $e');
      }
      await Future.delayed(Duration(seconds: 2));
    }
    print('Faucet request completed');


    // =========================================================
    // WaitForBalance (WaitForBalance)
    // =========================================================
    print('Waiting for balance >= 10000000...');
    final waitforbalanceMinBal = BigInt.parse('10000000'.replaceAll('.', ''));
    for (var i = 0; i < 30; i++) {
      try {
        final result = await client.v3.rawCall('query', {
          'scope': generatekeysLta.toString(),
          'query': {'queryType': 'default'},
        });
        final balance = result['account']?['balance'];
        if (balance != null && BigInt.parse(balance.toString()) >= waitforbalanceMinBal) break;
      } catch (_) {}
      await Future.delayed(Duration(seconds: 2));
    }
    print('Balance reached');


    // =========================================================
    // AddCredits (Action: AddCredits)
    // =========================================================
    final addcreditsOracle = await client.v3.rawCall('network-status', {});
    final addcreditsOraclePrice = addcreditsOracle['oracle']['price'] as int;
    final addcreditsSigner = SmartSigner(
      client: client.v3,
      keypair: generatekeysKey,
      signerUrl: generatekeysLid.toString(),
    );
    final addcreditsResult = await addcreditsSigner.signSubmitAndWait(
      principal: generatekeysLta.toString(),
      body: TxBody.addCredits(
        recipient: generatekeysLid.toString(),
        amount: '2000000',
        oracle: addcreditsOraclePrice,
      ),
      memo: 'Add credits',
      maxAttempts: 30,
    );
    if (addcreditsResult.success) {
      print('AddCredits SUCCESS - TxID: ${addcreditsResult.txid}');
      if (addcreditsResult.txid != null) {
        txIds.add(MapEntry('AddCredits', addcreditsResult.txid!));
      }
    } else {
      print('AddCredits FAILED: ${addcreditsResult.error}');
    }


    // =========================================================
    // WaitForCredits (WaitForCredits)
    // =========================================================
    print('Waiting for credits >= 100...');
    for (var i = 0; i < 30; i++) {
      try {
        final result = await client.v3.rawCall('query', {
          'scope': generatekeysLid.toString(),
          'query': {'queryType': 'default'},
        });
        final creditBalance = result['account']?['creditBalance'];
        if (creditBalance != null && (creditBalance as int) >= 100) break;
      } catch (_) {}
      await Future.delayed(Duration(seconds: 2));
    }
    print('Credits reached');


    // =========================================================
    // CreateIdentity (Action: CreateIdentity)
    // =========================================================
    final createidentitySigner = SmartSigner(
      client: client.v3,
      keypair: generatekeysKey,
      signerUrl: generatekeysLid.toString(),
    );
    final createidentityResult = await createidentitySigner.signSubmitAndWait(
      principal: generatekeysLta.toString(),
      body: TxBody.createIdentity(
        url: 'acc://e2e-6ddfe1f4.acme',
        keyBookUrl: 'acc://e2e-6ddfe1f4.acme/book',
        publicKeyHash: generatekeysPubHash,
      ),
      memo: 'Create ADI',
      maxAttempts: 30,
    );
    if (createidentityResult.success) {
      print('CreateIdentity SUCCESS - TxID: ${createidentityResult.txid}');
      if (createidentityResult.txid != null) {
        txIds.add(MapEntry('CreateIdentity', createidentityResult.txid!));
      }
    } else {
      print('CreateIdentity FAILED: ${createidentityResult.error}');
    }


    // =========================================================
    // AddCredits_2 (Action: AddCredits)
    // =========================================================
    final addcredits_2Oracle = await client.v3.rawCall('network-status', {});
    final addcredits_2OraclePrice = addcredits_2Oracle['oracle']['price'] as int;
    final addcredits_2Signer = SmartSigner(
      client: client.v3,
      keypair: generatekeysKey,
      signerUrl: generatekeysLid.toString(),
    );
    final addcredits_2Result = await addcredits_2Signer.signSubmitAndWait(
      principal: generatekeysLta.toString(),
      body: TxBody.addCredits(
        recipient: generatekeysLid.toString(),
        amount: '5000000',
        oracle: addcredits_2OraclePrice,
      ),
      memo: 'Add credits',
      maxAttempts: 30,
    );
    if (addcredits_2Result.success) {
      print('AddCredits SUCCESS - TxID: ${addcredits_2Result.txid}');
      if (addcredits_2Result.txid != null) {
        txIds.add(MapEntry('AddCredits', addcredits_2Result.txid!));
      }
    } else {
      print('AddCredits FAILED: ${addcredits_2Result.error}');
    }


    // =========================================================
    // WaitForCredits_2 (WaitForCredits)
    // =========================================================
    print('Waiting for credits >= 100...');
    for (var i = 0; i < 30; i++) {
      try {
        final result = await client.v3.rawCall('query', {
          'scope': generatekeysLid.toString(),
          'query': {'queryType': 'default'},
        });
        final creditBalance = result['account']?['creditBalance'];
        if (creditBalance != null && (creditBalance as int) >= 100) break;
      } catch (_) {}
      await Future.delayed(Duration(seconds: 2));
    }
    print('Credits reached');


    // =========================================================
    // CreateToken (Action: CreateToken)
    // =========================================================
    final createtokenSigner = SmartSigner(
      client: client.v3,
      keypair: generatekeysKey,
      signerUrl: generatekeysLid.toString(),
    );
    final createtokenResult = await createtokenSigner.signSubmitAndWait(
      principal: 'acc://e2e-6ddfe1f4.acme',
      body: TxBody.createToken(
        url: 'acc://e2e-6ddfe1f4.acme/my-token',
        symbol: 'TKN',
        precision: 8,
      ),
      memo: 'Create token',
      maxAttempts: 30,
    );
    if (createtokenResult.success) {
      print('CreateToken SUCCESS - TxID: ${createtokenResult.txid}');
      if (createtokenResult.txid != null) {
        txIds.add(MapEntry('CreateToken', createtokenResult.txid!));
      }
    } else {
      print('CreateToken FAILED: ${createtokenResult.error}');
    }


    // =========================================================
    // CreateTokenAccount (Action: CreateTokenAccount)
    // =========================================================
    final createtokenaccountSigner = SmartSigner(
      client: client.v3,
      keypair: generatekeysKey,
      signerUrl: generatekeysLid.toString(),
    );
    final createtokenaccountResult = await createtokenaccountSigner.signSubmitAndWait(
      principal: 'acc://e2e-6ddfe1f4.acme',
      body: TxBody.createTokenAccount(
        url: 'acc://e2e-6ddfe1f4.acme/tokens',
        tokenUrl: 'acc://ACME',
      ),
      memo: 'Create token account',
      maxAttempts: 30,
    );
    if (createtokenaccountResult.success) {
      print('CreateTokenAccount SUCCESS - TxID: ${createtokenaccountResult.txid}');
      if (createtokenaccountResult.txid != null) {
        txIds.add(MapEntry('CreateTokenAccount', createtokenaccountResult.txid!));
      }
    } else {
      print('CreateTokenAccount FAILED: ${createtokenaccountResult.error}');
    }


    // =========================================================
    // IssueTokens (Action: IssueTokens)
    // =========================================================
    final issuetokensSigner = SmartSigner(
      client: client.v3,
      keypair: generatekeysKey,
      signerUrl: generatekeysLid.toString(),
    );
    final issuetokensResult = await issuetokensSigner.signSubmitAndWait(
      principal: 'acc://e2e-6ddfe1f4.acme/my-token',
      body: TxBody.issueTokensSingle(
        toUrl: 'acc://e2e-6ddfe1f4.acme/tokens',
        amount: '1000000',
      ),
      memo: 'Issue tokens',
      maxAttempts: 30,
    );
    if (issuetokensResult.success) {
      print('IssueTokens SUCCESS - TxID: ${issuetokensResult.txid}');
      if (issuetokensResult.txid != null) {
        txIds.add(MapEntry('IssueTokens', issuetokensResult.txid!));
      }
    } else {
      print('IssueTokens FAILED: ${issuetokensResult.error}');
    }


    // =========================================================
    // BurnTokens (Action: BurnTokens)
    // =========================================================
    final burntokensSigner = SmartSigner(
      client: client.v3,
      keypair: generatekeysKey,
      signerUrl: generatekeysLid.toString(),
    );
    final burntokensResult = await burntokensSigner.signSubmitAndWait(
      principal: 'acc://e2e-6ddfe1f4.acme/tokens',
      body: TxBody.burnTokens(
        amount: '500',
      ),
      memo: 'Burn tokens',
      maxAttempts: 30,
    );
    if (burntokensResult.success) {
      print('BurnTokens SUCCESS - TxID: ${burntokensResult.txid}');
      if (burntokensResult.txid != null) {
        txIds.add(MapEntry('BurnTokens', burntokensResult.txid!));
      }
    } else {
      print('BurnTokens FAILED: ${burntokensResult.error}');
    }


    print('\n========== Transaction Summary ==========');
    for (final entry in txIds) {
      print('  ${entry.key}: ${entry.value}');
    }
    print('Flow completed successfully!');
  } finally {
    client.close();
  }
}
