/**
 * Agent Files Generator - Generate agent-friendly documentation and configs
 */

import type { Flow, FlowNode, FlowVariable, NetworkId } from '@accumulate-studio/types';

// =============================================================================
// Types
// =============================================================================

export interface AgentPackRef {
  /** Reference to the agent pack */
  pack: string;
  /** Pack version */
  version: string;
  /** Required MCP servers */
  mcpServers: string[];
  /** Flow-specific context */
  context: {
    flowName: string;
    flowDescription?: string;
    network: NetworkId;
    variables: string[];
    blockTypes: string[];
  };
}

export interface MCPConfig {
  /** MCP server configurations */
  mcpServers: Record<string, MCPServerConfig>;
}

export interface MCPServerConfig {
  /** Server command */
  command: string;
  /** Server arguments */
  args: string[];
  /** Environment variables */
  env?: Record<string, string>;
}

// =============================================================================
// Agent Task Generator
// =============================================================================

/**
 * Generate agent-task.md - Task description for AI agents
 */
export function generateAgentTask(flow: Flow): string {
  const blockSummary = summarizeBlocks(flow.nodes);
  const variableList = formatVariableList(flow.variables);
  const stepsList = formatStepsList(flow.nodes);

  return `# Agent Task: ${flow.name}

## Overview

${flow.description ?? 'Execute the following Accumulate protocol flow.'}

## Target Network

**Network**: ${flow.network ?? 'testnet'}

## Required Variables

${variableList || 'No variables required.'}

## Flow Steps

${stepsList}

## Block Summary

${blockSummary}

## Execution Instructions

1. **Setup**: Ensure all required environment variables are set
2. **Connect**: Initialize connection to the ${flow.network ?? 'testnet'} network
3. **Execute**: Run each step in order, waiting for confirmation between transactions
4. **Verify**: Check assertions after each step completes
5. **Report**: Provide execution results and any errors encountered

## Error Handling

- If a transaction fails, report the error code and message
- Do not proceed to dependent steps if a prerequisite fails
- Retry transient failures (network timeouts) up to 3 times
- For permanent failures, stop execution and report status

## Success Criteria

All steps must complete successfully with verified receipts for each transaction.

---
*Generated by Accumulate Studio*
`;
}

/**
 * Summarize blocks by category
 */
function summarizeBlocks(nodes: FlowNode[]): string {
  const categories: Record<string, string[]> = {
    'Identity Operations': [],
    'Account Operations': [],
    'Token Operations': [],
    'Credit Operations': [],
    'Data Operations': [],
    'Key Management': [],
    'Utility Operations': [],
  };

  for (const node of nodes) {
    const category = getBlockCategory(node.type);
    categories[category].push(`- ${node.type}${node.label ? ` (${node.label})` : ''}`);
  }

  return Object.entries(categories)
    .filter(([, blocks]) => blocks.length > 0)
    .map(([category, blocks]) => `### ${category}\n\n${blocks.join('\n')}`)
    .join('\n\n');
}

/**
 * Get block category name
 */
function getBlockCategory(type: string): string {
  const categoryMap: Record<string, string> = {
    CreateIdentity: 'Identity Operations',
    CreateKeyBook: 'Identity Operations',
    CreateKeyPage: 'Identity Operations',
    CreateTokenAccount: 'Account Operations',
    CreateDataAccount: 'Account Operations',
    CreateToken: 'Account Operations',
    CreateLiteTokenAccount: 'Account Operations',
    SendTokens: 'Token Operations',
    IssueTokens: 'Token Operations',
    BurnTokens: 'Token Operations',
    AddCredits: 'Credit Operations',
    TransferCredits: 'Credit Operations',
    BurnCredits: 'Credit Operations',
    WriteData: 'Data Operations',
    WriteDataTo: 'Data Operations',
    UpdateKeyPage: 'Key Management',
    UpdateKey: 'Key Management',
    LockAccount: 'Key Management',
    UpdateAccountAuth: 'Key Management',
    Faucet: 'Utility Operations',
    QueryAccount: 'Utility Operations',
    WaitForBalance: 'Utility Operations',
    WaitForCredits: 'Utility Operations',
    GenerateKeys: 'Utility Operations',
    Comment: 'Utility Operations',
  };

  return categoryMap[type] ?? 'Utility Operations';
}

/**
 * Format variable list for documentation
 */
function formatVariableList(variables: FlowVariable[]): string {
  if (variables.length === 0) return '';

  return variables
    .map((v) => {
      const flags: string[] = [];
      if (v.required !== false) flags.push('required');
      if (v.secret) flags.push('secret');
      if (v.default !== undefined) flags.push(`default: ${v.default}`);

      const flagStr = flags.length > 0 ? ` (${flags.join(', ')})` : '';

      return `- **${v.name}** (\`${v.type}\`)${flagStr}: ${v.description ?? 'No description'}`;
    })
    .join('\n');
}

/**
 * Format steps list for documentation
 */
function formatStepsList(nodes: FlowNode[]): string {
  return nodes
    .map((node, index) => {
      const config = node.config as Record<string, unknown>;
      const configSummary = Object.entries(config)
        .slice(0, 3)
        .map(([k, v]) => `${k}: ${JSON.stringify(v)}`)
        .join(', ');

      return `${index + 1}. **${node.id}**: ${node.type}
   - Config: ${configSummary || 'none'}`;
    })
    .join('\n');
}

// =============================================================================
// Agent Acceptance Generator
// =============================================================================

/**
 * Generate agent-acceptance.md - Acceptance criteria for AI agents
 */
export function generateAgentAcceptance(flow: Flow): string {
  const acceptanceCriteria = generateAcceptanceCriteria(flow);
  const verificationSteps = generateVerificationSteps(flow);

  return `# Acceptance Criteria: ${flow.name}

## Overview

This document defines the acceptance criteria for the "${flow.name}" flow.
An AI agent must satisfy all criteria to consider the task complete.

## Pre-conditions

${generatePreconditions(flow)}

## Acceptance Criteria

${acceptanceCriteria}

## Verification Steps

${verificationSteps}

## Post-conditions

${generatePostconditions(flow)}

## Evidence Required

For each completed step, provide:

1. **Transaction Hash**: The unique identifier for the transaction
2. **Block Height**: The block in which the transaction was included
3. **Receipt**: Merkle proof of inclusion (if available)
4. **Status**: Final transaction status (delivered/confirmed)

## Failure Modes

The following are considered failures:

- Transaction rejected by the network
- Transaction status remains pending for > 5 minutes
- Receipt verification fails
- Account state does not match expected values
- Any required assertion fails

---
*Generated by Accumulate Studio*
`;
}

/**
 * Generate preconditions
 */
function generatePreconditions(flow: Flow): string {
  const conditions: string[] = [];

  // Network connectivity
  conditions.push(`- [ ] Connected to ${flow.network ?? 'testnet'} network`);

  // Required variables
  for (const variable of flow.variables) {
    if (variable.required !== false) {
      conditions.push(`- [ ] Variable \`${variable.name}\` is set`);
    }
  }

  // Signing keys
  const needsSigner = flow.nodes.some((n) => isTransactionBlock(n.type));
  if (needsSigner) {
    conditions.push('- [ ] Signing key is available');
    conditions.push('- [ ] Key page has sufficient credits');
  }

  // Faucet availability
  const usesFaucet = flow.nodes.some((n) => n.type === 'Faucet');
  if (usesFaucet) {
    conditions.push('- [ ] Faucet is available on target network');
  }

  return conditions.join('\n');
}

/**
 * Generate acceptance criteria
 */
function generateAcceptanceCriteria(flow: Flow): string {
  const criteria: string[] = [];

  for (const node of flow.nodes) {
    const nodeCriteria = getNodeAcceptanceCriteria(node);
    criteria.push(...nodeCriteria);
  }

  // Add assertion criteria
  if (flow.assertions && flow.assertions.length > 0) {
    criteria.push('\n### Assertions\n');
    for (const assertion of flow.assertions) {
      criteria.push(`- [ ] ${assertion.message ?? formatAssertion(assertion)}`);
    }
  }

  return criteria.join('\n');
}

/**
 * Get acceptance criteria for a specific node
 */
function getNodeAcceptanceCriteria(node: FlowNode): string[] {
  const criteria: string[] = [`\n### ${node.id}: ${node.type}\n`];
  const config = node.config as Record<string, unknown>;

  switch (node.type) {
    case 'CreateIdentity':
      criteria.push(`- [ ] ADI \`${config.url}\` is created`);
      criteria.push(`- [ ] Key book exists at \`${config.keyBookUrl ?? `${config.url}/book`}\``);
      criteria.push('- [ ] Key page 1 exists in the key book');
      criteria.push('- [ ] Transaction receipt is verified');
      break;

    case 'CreateTokenAccount':
      criteria.push(`- [ ] Token account \`${config.url}\` is created`);
      criteria.push(`- [ ] Account is associated with token \`${config.tokenUrl}\``);
      criteria.push('- [ ] Transaction receipt is verified');
      break;

    case 'SendTokens': {
      const recipients = config.recipients as Array<{ url: string; amount: string }> ?? [];
      for (const r of recipients) {
        criteria.push(`- [ ] ${r.amount} tokens delivered to \`${r.url}\``);
      }
      criteria.push('- [ ] Transaction receipt is verified');
      break;
    }

    case 'AddCredits':
      criteria.push(`- [ ] Credits purchased for \`${config.recipient}\``);
      criteria.push('- [ ] Transaction receipt is verified');
      break;

    case 'Faucet':
      criteria.push(`- [ ] Faucet request successful for \`${config.account}\``);
      criteria.push('- [ ] Tokens deposited to account');
      break;

    case 'GenerateKeys':
      criteria.push('- [ ] Ed25519 keypair generated');
      criteria.push('- [ ] Public key hash computed');
      criteria.push('- [ ] Lite identity URL derived');
      break;

    default:
      criteria.push('- [ ] Step completes successfully');
      if (isTransactionBlock(node.type)) {
        criteria.push('- [ ] Transaction receipt is verified');
      }
  }

  return criteria;
}

/**
 * Generate verification steps
 */
function generateVerificationSteps(flow: Flow): string {
  const steps: string[] = [];

  steps.push('1. **Query all created accounts** to verify they exist');
  steps.push('2. **Check token balances** match expected values');
  steps.push('3. **Verify all transaction receipts** using Merkle proofs');
  steps.push('4. **Confirm synthetic transactions** have been delivered');
  steps.push('5. **Run all defined assertions** and report results');

  return steps.join('\n');
}

/**
 * Generate postconditions
 */
function generatePostconditions(flow: Flow): string {
  const conditions: string[] = [];

  // Check for created accounts
  for (const node of flow.nodes) {
    const config = node.config as Record<string, unknown>;

    switch (node.type) {
      case 'CreateIdentity':
        conditions.push(`- [ ] ADI \`${config.url}\` exists and is queryable`);
        break;
      case 'CreateTokenAccount':
        conditions.push(`- [ ] Token account \`${config.url}\` exists`);
        break;
      case 'CreateDataAccount':
        conditions.push(`- [ ] Data account \`${config.url}\` exists`);
        break;
    }
  }

  if (conditions.length === 0) {
    conditions.push('- [ ] All steps completed without errors');
  }

  return conditions.join('\n');
}

/**
 * Format an assertion for display
 */
function formatAssertion(assertion: { type: string; [key: string]: unknown }): string {
  switch (assertion.type) {
    case 'account.exists':
      return `Account ${assertion.url} exists`;
    case 'account.not_exists':
      return `Account ${assertion.url} does not exist`;
    case 'balance.delta':
      return `Balance of ${assertion.account} changed by ${assertion.delta}`;
    case 'balance.equals':
      return `Balance of ${assertion.account} equals ${assertion.equals}`;
    case 'receipt.verified':
      return `Receipt for step ${assertion.sourceStep} is verified`;
    case 'tx.status.equals':
      return `Transaction ${assertion.sourceStep} has status ${assertion.status}`;
    default:
      return `${assertion.type} assertion passes`;
  }
}

/**
 * Check if block type is a transaction
 */
function isTransactionBlock(type: string): boolean {
  const transactionTypes = [
    'CreateIdentity',
    'CreateKeyBook',
    'CreateKeyPage',
    'CreateTokenAccount',
    'CreateDataAccount',
    'CreateToken',
    'CreateLiteTokenAccount',
    'SendTokens',
    'IssueTokens',
    'BurnTokens',
    'AddCredits',
    'TransferCredits',
    'BurnCredits',
    'WriteData',
    'WriteDataTo',
    'UpdateKeyPage',
    'UpdateKey',
    'LockAccount',
    'UpdateAccountAuth',
  ];
  return transactionTypes.includes(type);
}

// =============================================================================
// Agent Pack Reference Generator
// =============================================================================

/**
 * Generate agent-pack.ref.json - Reference to the Accumulate Agent Pack
 */
export function generateAgentPackRef(flow: Flow): AgentPackRef {
  const blockTypes = [...new Set(flow.nodes.map((n) => n.type))];
  const variableNames = flow.variables.map((v) => v.name);

  return {
    pack: '@accumulate-studio/agent-pack',
    version: '1.0.0',
    mcpServers: ['accumulate-mcp'],
    context: {
      flowName: flow.name,
      flowDescription: flow.description,
      network: flow.network ?? 'testnet',
      variables: variableNames,
      blockTypes,
    },
  };
}

// =============================================================================
// MCP Config Generator
// =============================================================================

/**
 * Generate mcp.config.json - MCP server configuration
 */
export function generateMCPConfig(flow: Flow): MCPConfig {
  return {
    mcpServers: {
      'accumulate-mcp': {
        command: 'npx',
        args: ['-y', '@accumulate-studio/mcp-server'],
        env: {
          ACCUMULATE_NETWORK: flow.network ?? 'testnet',
        },
      },
    },
  };
}

/**
 * Generate MCP config as JSON string
 */
export function generateMCPConfigJson(flow: Flow): string {
  return JSON.stringify(generateMCPConfig(flow), null, 2);
}

// =============================================================================
// Combined Agent Files Generator
// =============================================================================

export interface AgentFiles {
  'agent-task.md': string;
  'agent-acceptance.md': string;
  'agent-pack.ref.json': string;
  'mcp.config.json': string;
}

/**
 * Generate all agent files for a flow
 */
export function generateAllAgentFiles(flow: Flow): AgentFiles {
  return {
    'agent-task.md': generateAgentTask(flow),
    'agent-acceptance.md': generateAgentAcceptance(flow),
    'agent-pack.ref.json': JSON.stringify(generateAgentPackRef(flow), null, 2),
    'mcp.config.json': generateMCPConfigJson(flow),
  };
}
