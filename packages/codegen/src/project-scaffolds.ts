/**
 * Project Scaffolds - Generate language-specific project structures
 */

import type { Flow, GeneratedFile, SDKLanguage } from '@accumulate-studio/types';
import { serializeFlowToYaml } from './flow-serializer';

// =============================================================================
// Types
// =============================================================================

export interface ProjectGenerator {
  (flow: Flow): GeneratedFile[];
}

// =============================================================================
// Python Project Generator
// =============================================================================

export function generatePythonProject(flow: Flow): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const safeName = toSnakeCase(flow.name);

  // pyproject.toml
  files.push({
    path: 'pyproject.toml',
    content: `[project]
name = "${safeName}"
version = "0.1.0"
description = "${flow.description ?? `Accumulate flow: ${flow.name}`}"
readme = "README.md"
requires-python = ">=3.10"
dependencies = [
    "accumulate-sdk-opendlt==2.0.2",
    "pyyaml>=6.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "pytest-asyncio>=0.21",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.pytest.ini_options]
asyncio_mode = "auto"
`,
  });

  // Main Python file
  files.push({
    path: `${safeName}/main.py`,
    content: generatePythonMain(flow),
    isEntryPoint: true,
  });

  // __init__.py
  files.push({
    path: `${safeName}/__init__.py`,
    content: `"""${flow.name} - Generated by Accumulate Studio"""

from .main import run_flow

__all__ = ["run_flow"]
`,
  });

  // README.md
  files.push({
    path: 'README.md',
    content: generatePythonReadme(flow, safeName),
  });

  return files;
}

function generatePythonMain(flow: Flow): string {
  const imports = `"""
${flow.name}
${flow.description ?? 'Generated by Accumulate Studio'}
"""

import asyncio
import os
from accumulate_client import Accumulate
from accumulate_client.convenience import TxBody, SmartSigner
`;

  const variableLoading = flow.variables
    .map((v) => {
      const envName = v.name.toUpperCase();
      if (v.required !== false) {
        return `    ${v.name} = os.environ["${envName}"]`;
      }
      const defaultVal = v.default !== undefined ? `"${v.default}"` : 'None';
      return `    ${v.name} = os.environ.get("${envName}", ${defaultVal})`;
    })
    .join('\n');

  const blockExecution = generatePythonBlockExecution(flow);

  return `${imports}

async def run_flow():
    """Execute the ${flow.name} flow."""

    # Load variables from environment
${variableLoading || '    pass  # No variables defined'}

    # Initialize client
    client = Accumulate.${flow.network ?? 'testnet'}()

    # Execute flow blocks
${blockExecution}

    print("Flow completed successfully!")
    return results


if __name__ == "__main__":
    asyncio.run(run_flow())
`;
}

function generatePythonBlockExecution(flow: Flow): string {
  const lines: string[] = ['    results = {}'];

  for (const node of flow.nodes) {
    const config = node.config as Record<string, unknown>;
    const stepId = node.id;

    switch (node.type) {
      case 'GenerateKeys':
        lines.push(`
    # ${stepId}: Generate Keys
    from accumulate_client.crypto import generate_ed25519_keypair
    keypair = generate_ed25519_keypair()
    results["${stepId}"] = {
        "publicKey": keypair.public_key.hex(),
        "publicKeyHash": keypair.public_key_hash.hex(),
    }`);
        break;

      case 'Faucet':
        lines.push(`
    # ${stepId}: Request from faucet
    faucet_result = await client.faucet("${config.account ?? '${LITE_ACCOUNT}'}")
    results["${stepId}"] = faucet_result`);
        break;

      case 'CreateIdentity':
        lines.push(`
    # ${stepId}: Create ADI
    tx = TxBody.create_identity(
        url="${config.url ?? '${ADI_URL}'}",
        public_key_hash="${config.publicKeyHash ?? '${PUBLIC_KEY_HASH}'}",
        ${config.keyBookUrl ? `key_book_url="${config.keyBookUrl}",` : ''}
    )
    result = await client.submit_and_wait(tx, signer)
    results["${stepId}"] = result`);
        break;

      case 'CreateTokenAccount':
        lines.push(`
    # ${stepId}: Create Token Account
    tx = TxBody.create_token_account(
        url="${config.url ?? '${TOKEN_ACCOUNT_URL}'}",
        token_url="${config.tokenUrl ?? 'acc://ACME'}",
    )
    result = await client.submit_and_wait(tx, signer)
    results["${stepId}"] = result`);
        break;

      case 'SendTokens':
        const recipients = config.recipients as Array<{ url: string; amount: string }> ?? [];
        const recipientStr = recipients
          .map((r) => `("${r.url}", "${r.amount}")`)
          .join(', ');
        lines.push(`
    # ${stepId}: Send Tokens
    tx = TxBody.send_tokens(
        recipients=[${recipientStr}],
    )
    result = await client.submit_and_wait(tx, signer)
    results["${stepId}"] = result`);
        break;

      case 'AddCredits':
        lines.push(`
    # ${stepId}: Add Credits
    tx = TxBody.add_credits(
        recipient="${config.recipient ?? '${KEY_PAGE_URL}'}",
        amount="${config.amount ?? '1000000'}",
    )
    result = await client.submit_and_wait(tx, signer)
    results["${stepId}"] = result`);
        break;

      default:
        lines.push(`
    # ${stepId}: ${node.type}
    # TODO: Implement ${node.type}
    results["${stepId}"] = {"status": "not_implemented"}`);
    }
  }

  return lines.join('\n');
}

function generatePythonReadme(flow: Flow, safeName: string): string {
  return `# ${flow.name}

${flow.description ?? 'Generated by Accumulate Studio'}

## Installation

\`\`\`bash
pip install -e .
\`\`\`

## Environment Variables

${flow.variables.map((v) => `- \`${v.name.toUpperCase()}\`: ${v.description ?? v.type}${v.required === false ? ' (optional)' : ''}`).join('\n') || 'No environment variables required.'}

## Usage

\`\`\`bash
python -m ${safeName}.main
\`\`\`

Or as a library:

\`\`\`python
import asyncio
from ${safeName} import run_flow

asyncio.run(run_flow())
\`\`\`

## Generated by Accumulate Studio

This project was automatically generated from a visual flow definition.
`;
}

// =============================================================================
// Rust Project Generator
// =============================================================================

export function generateRustProject(flow: Flow): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const safeName = toSnakeCase(flow.name);

  // Cargo.toml
  files.push({
    path: 'Cargo.toml',
    content: `[package]
name = "${safeName}"
version = "0.1.0"
edition = "2021"
description = "${flow.description ?? `Accumulate flow: ${flow.name}`}"

[dependencies]
accumulate-sdk = "2.0"
tokio = { version = "1", features = ["full"] }
anyhow = "1.0"
serde = { version = "1.0", features = ["derive"] }
serde_yaml = "0.9"

[dev-dependencies]
tokio-test = "0.4"
`,
  });

  // Main Rust file
  files.push({
    path: 'src/main.rs',
    content: generateRustMain(flow),
    isEntryPoint: true,
  });

  // README.md
  files.push({
    path: 'README.md',
    content: generateRustReadme(flow, safeName),
  });

  return files;
}

function generateRustMain(flow: Flow): string {
  const variableLoading = flow.variables
    .map((v) => {
      const envName = v.name.toUpperCase();
      if (v.required !== false) {
        return `    let ${toSnakeCase(v.name)} = std::env::var("${envName}")?;`;
      }
      const defaultVal = v.default !== undefined ? `"${v.default}".to_string()` : 'String::new()';
      return `    let ${toSnakeCase(v.name)} = std::env::var("${envName}").unwrap_or(${defaultVal});`;
    })
    .join('\n');

  return `//! ${flow.name}
//! ${flow.description ?? 'Generated by Accumulate Studio'}

use accumulate_client::{AccumulateClient, AccOptions};
use accumulate_client::{SmartSigner, TxBody};
use anyhow::Result;
use std::collections::HashMap;

#[tokio::main]
async fn main() -> Result<()> {
    run_flow().await
}

async fn run_flow() -> Result<()> {
    // Load variables from environment
${variableLoading || '    // No variables defined'}

    // Initialize client
    let client = AccumulateClient::${flow.network ?? 'testnet'}()?;

    // Results storage
    let mut results: HashMap<String, serde_yaml::Value> = HashMap::new();

    // Execute flow blocks
${generateRustBlockExecution(flow)}

    println!("Flow completed successfully!");
    Ok(())
}
`;
}

function generateRustBlockExecution(flow: Flow): string {
  const lines: string[] = [];

  for (const node of flow.nodes) {
    const config = node.config as Record<string, unknown>;
    const stepId = node.id;

    switch (node.type) {
      case 'GenerateKeys':
        lines.push(`
    // ${stepId}: Generate Keys
    let keypair = accumulate_client::crypto::generate_ed25519_keypair()?;
    results.insert("${stepId}".to_string(), serde_yaml::to_value(&keypair)?);`);
        break;

      case 'Faucet':
        lines.push(`
    // ${stepId}: Request from faucet
    let faucet_result = client.faucet("${config.account ?? '${LITE_ACCOUNT}'}").await?;
    results.insert("${stepId}".to_string(), serde_yaml::to_value(&faucet_result)?);`);
        break;

      case 'CreateIdentity':
        lines.push(`
    // ${stepId}: Create ADI
    let tx = TxBody::create_identity()
        .url("${config.url ?? '${ADI_URL}'}")
        .public_key_hash("${config.publicKeyHash ?? '${PUBLIC_KEY_HASH}'}")
        .build()?;
    let result = client.submit_and_wait(&tx, &signer).await?;
    results.insert("${stepId}".to_string(), serde_yaml::to_value(&result)?);`);
        break;

      case 'CreateTokenAccount':
        lines.push(`
    // ${stepId}: Create Token Account
    let tx = TxBody::create_token_account()
        .url("${config.url ?? '${TOKEN_ACCOUNT_URL}'}")
        .token_url("${config.tokenUrl ?? 'acc://ACME'}")
        .build()?;
    let result = client.submit_and_wait(&tx, &signer).await?;
    results.insert("${stepId}".to_string(), serde_yaml::to_value(&result)?);`);
        break;

      case 'SendTokens': {
        const rustRecipients = (config.recipients as Array<{ url: string; amount: string }>) ?? [];
        const rustRecipStr = rustRecipients
          .map((r) => `("${r.url}", "${r.amount}")`)
          .join(', ');
        lines.push(`
    // ${stepId}: Send Tokens
    let tx = TxBody::send_tokens()
        .recipients(vec![${rustRecipStr}])
        .build()?;
    let result = client.submit_and_wait(&tx, &signer).await?;
    results.insert("${stepId}".to_string(), serde_yaml::to_value(&result)?);`);
        break;
      }

      case 'AddCredits':
        lines.push(`
    // ${stepId}: Add Credits
    let tx = TxBody::add_credits()
        .recipient("${config.recipient ?? '${KEY_PAGE_URL}'}")
        .amount("${config.amount ?? '1000000'}")
        .build()?;
    let result = client.submit_and_wait(&tx, &signer).await?;
    results.insert("${stepId}".to_string(), serde_yaml::to_value(&result)?);`);
        break;

      default:
        lines.push(`
    // ${stepId}: ${node.type}
    // TODO: Implement ${node.type}`);
    }
  }

  return lines.join('\n');
}

function generateRustReadme(flow: Flow, safeName: string): string {
  return `# ${flow.name}

${flow.description ?? 'Generated by Accumulate Studio'}

## Build

\`\`\`bash
cargo build --release
\`\`\`

## Environment Variables

${flow.variables.map((v) => `- \`${v.name.toUpperCase()}\`: ${v.description ?? v.type}${v.required === false ? ' (optional)' : ''}`).join('\n') || 'No environment variables required.'}

## Usage

\`\`\`bash
cargo run
\`\`\`

## Generated by Accumulate Studio

This project was automatically generated from a visual flow definition.
`;
}

// =============================================================================
// Dart Project Generator
// =============================================================================

export function generateDartProject(flow: Flow): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const safeName = toSnakeCase(flow.name);

  // pubspec.yaml
  files.push({
    path: 'pubspec.yaml',
    content: `name: ${safeName}
description: ${flow.description ?? `Accumulate flow: ${flow.name}`}
version: 0.1.0

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  opendlt_accumulate: ^2.0.2
  yaml: ^3.1.0

dev_dependencies:
  test: ^1.24.0
`,
  });

  // Main Dart file
  files.push({
    path: 'bin/main.dart',
    content: generateDartMain(flow),
    isEntryPoint: true,
  });

  // Library file
  files.push({
    path: `lib/${safeName}.dart`,
    content: `/// ${flow.name}
/// ${flow.description ?? 'Generated by Accumulate Studio'}
library ${safeName};

export 'src/flow.dart';
`,
  });

  // Flow implementation
  files.push({
    path: 'lib/src/flow.dart',
    content: generateDartFlow(flow),
  });

  // README.md
  files.push({
    path: 'README.md',
    content: generateDartReadme(flow, safeName),
  });

  return files;
}

function generateDartMain(flow: Flow): string {
  return `import 'package:${toSnakeCase(flow.name)}/src/flow.dart';

void main() async {
  final results = await runFlow();
  print('Flow completed successfully!');
  print(results);
}
`;
}

function generateDartFlow(flow: Flow): string {
  const variableLoading = flow.variables
    .map((v) => {
      const envName = v.name.toUpperCase();
      if (v.required !== false) {
        return `  final ${toCamelCase(v.name)} = Platform.environment['${envName}']!;`;
      }
      const defaultVal = v.default !== undefined ? `'${v.default}'` : "''";
      return `  final ${toCamelCase(v.name)} = Platform.environment['${envName}'] ?? ${defaultVal};`;
    })
    .join('\n');

  return `/// ${flow.name} flow implementation
import 'dart:io';
import 'package:opendlt_accumulate/opendlt_accumulate.dart';

/// Execute the ${flow.name} flow
Future<Map<String, dynamic>> runFlow() async {
  // Load variables from environment
${variableLoading || '  // No variables defined'}

  // Initialize client
  final client = Accumulate.network(Network.${flow.network ?? 'testnet'});

  // Results storage
  final results = <String, dynamic>{};

  // Execute flow blocks
${generateDartBlockExecution(flow)}

  return results;
}
`;
}

function generateDartBlockExecution(flow: Flow): string {
  const lines: string[] = [];

  for (const node of flow.nodes) {
    const config = node.config as Record<string, unknown>;
    const stepId = node.id;

    switch (node.type) {
      case 'GenerateKeys':
        lines.push(`
  // ${stepId}: Generate Keys
  final keypair = AccumulateHelper.generateEd25519Keypair();
  results['${stepId}'] = {
    'publicKey': keypair.publicKey,
    'publicKeyHash': keypair.publicKeyHash,
  };`);
        break;

      case 'Faucet':
        lines.push(`
  // ${stepId}: Request from faucet
  final faucetResult = await client.faucet('${config.account ?? '\${LITE_ACCOUNT}'}');
  results['${stepId}'] = faucetResult;`);
        break;

      case 'CreateIdentity':
        lines.push(`
  // ${stepId}: Create ADI
  final tx = TxBody.createIdentity(
    url: '${config.url ?? '\${ADI_URL}'}',
    publicKeyHash: '${config.publicKeyHash ?? '\${PUBLIC_KEY_HASH}'}',
  );
  final result = await client.submitAndWait(tx, signer);
  results['${stepId}'] = result;`);
        break;

      case 'CreateTokenAccount':
        lines.push(`
  // ${stepId}: Create Token Account
  final tx = TxBody.createTokenAccount(
    url: '${config.url ?? '\${TOKEN_ACCOUNT_URL}'}',
    tokenUrl: '${config.tokenUrl ?? 'acc://ACME'}',
  );
  final result = await client.submitAndWait(tx, signer);
  results['${stepId}'] = result;`);
        break;

      case 'SendTokens': {
        const dartRecipients = (config.recipients as Array<{ url: string; amount: string }>) ?? [];
        const dartRecipStr = dartRecipients
          .map((r) => `{'url': '${r.url}', 'amount': '${r.amount}'}`)
          .join(', ');
        lines.push(`
  // ${stepId}: Send Tokens
  final tx = TxBody.sendTokens(
    recipients: [${dartRecipStr}],
  );
  final result = await client.submitAndWait(tx, signer);
  results['${stepId}'] = result;`);
        break;
      }

      case 'AddCredits':
        lines.push(`
  // ${stepId}: Add Credits
  final tx = TxBody.addCredits(
    recipient: '${config.recipient ?? '\${KEY_PAGE_URL}'}',
    amount: '${config.amount ?? '1000000'}',
  );
  final result = await client.submitAndWait(tx, signer);
  results['${stepId}'] = result;`);
        break;

      default:
        lines.push(`
  // ${stepId}: ${node.type}
  // TODO: Implement ${node.type}
  results['${stepId}'] = {'status': 'not_implemented'};`);
    }
  }

  return lines.join('\n');
}

function generateDartReadme(flow: Flow, safeName: string): string {
  return `# ${flow.name}

${flow.description ?? 'Generated by Accumulate Studio'}

## Installation

\`\`\`bash
dart pub get
\`\`\`

## Environment Variables

${flow.variables.map((v) => `- \`${v.name.toUpperCase()}\`: ${v.description ?? v.type}${v.required === false ? ' (optional)' : ''}`).join('\n') || 'No environment variables required.'}

## Usage

\`\`\`bash
dart run
\`\`\`

## Generated by Accumulate Studio

This project was automatically generated from a visual flow definition.
`;
}

// =============================================================================
// JavaScript/TypeScript Project Generator
// =============================================================================

export function generateJavaScriptProject(flow: Flow): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const safeName = toKebabCase(flow.name);

  // package.json
  files.push({
    path: 'package.json',
    content: JSON.stringify(
      {
        name: safeName,
        version: '0.1.0',
        description: flow.description ?? `Accumulate flow: ${flow.name}`,
        type: 'module',
        main: 'src/index.js',
        scripts: {
          start: 'node src/index.js',
          test: 'node --test',
        },
        dependencies: {
          'accumulate.js': '^0.12.0',
          'js-yaml': '^4.1.0',
        },
        devDependencies: {},
      },
      null,
      2
    ),
  });

  // Main JS file
  files.push({
    path: 'src/index.js',
    content: generateJavaScriptMain(flow),
    isEntryPoint: true,
  });

  // README.md
  files.push({
    path: 'README.md',
    content: generateJavaScriptReadme(flow, safeName),
  });

  return files;
}

function generateJavaScriptMain(flow: Flow): string {
  const variableLoading = flow.variables
    .map((v) => {
      const envName = v.name.toUpperCase();
      if (v.required !== false) {
        return `const ${toCamelCase(v.name)} = process.env.${envName};
if (!${toCamelCase(v.name)}) throw new Error('Missing required env var: ${envName}');`;
      }
      const defaultVal = v.default !== undefined ? `'${v.default}'` : "''";
      return `const ${toCamelCase(v.name)} = process.env.${envName} ?? ${defaultVal};`;
    })
    .join('\n');

  return `/**
 * ${flow.name}
 * ${flow.description ?? 'Generated by Accumulate Studio'}
 */

import { Accumulate, TxBody, SmartSigner, Ed25519KeyPair } from 'accumulate.js';

export async function runFlow() {
  // Load variables from environment
  ${variableLoading || '// No variables defined'}

  // Initialize client
  const client = Accumulate.${flow.network ?? 'testnet'}();

  // Results storage
  const results = {};

  // Execute flow blocks
${generateJavaScriptBlockExecution(flow)}

  console.log('Flow completed successfully!');
  return results;
}

// Run if executed directly
runFlow().catch(console.error);
`;
}

function generateJavaScriptBlockExecution(flow: Flow): string {
  const lines: string[] = [];

  for (const node of flow.nodes) {
    const config = node.config as Record<string, unknown>;
    const stepId = node.id;

    switch (node.type) {
      case 'GenerateKeys':
        lines.push(`
  // ${stepId}: Generate Keys
  const keypair = await Accumulate.generateEd25519Keypair();
  results['${stepId}'] = {
    publicKey: keypair.publicKey,
    publicKeyHash: keypair.publicKeyHash,
  };`);
        break;

      case 'Faucet':
        lines.push(`
  // ${stepId}: Request from faucet
  const faucetResult = await client.faucet('${config.account ?? '${LITE_ACCOUNT}'}');
  results['${stepId}'] = faucetResult;`);
        break;

      case 'CreateIdentity':
        lines.push(`
  // ${stepId}: Create ADI
  const tx = TxBody.createIdentity({
    url: '${config.url ?? '${ADI_URL}'}',
    publicKeyHash: '${config.publicKeyHash ?? '${PUBLIC_KEY_HASH}'}',
  });
  const result = await client.submitAndWait(tx, signer);
  results['${stepId}'] = result;`);
        break;

      case 'CreateTokenAccount':
        lines.push(`
  // ${stepId}: Create Token Account
  const createTaTx = TxBody.createTokenAccount({
    url: '${config.url ?? '${TOKEN_ACCOUNT_URL}'}',
    tokenUrl: '${config.tokenUrl ?? 'acc://ACME'}',
  });
  const createTaResult = await client.submitAndWait(createTaTx, signer);
  results['${stepId}'] = createTaResult;`);
        break;

      case 'SendTokens': {
        const jsRecipients = (config.recipients as Array<{ url: string; amount: string }>) ?? [];
        const jsRecipStr = jsRecipients
          .map((r) => `{ url: '${r.url}', amount: '${r.amount}' }`)
          .join(', ');
        lines.push(`
  // ${stepId}: Send Tokens
  const sendTx = TxBody.sendTokens({
    recipients: [${jsRecipStr}],
  });
  const sendResult = await client.submitAndWait(sendTx, signer);
  results['${stepId}'] = sendResult;`);
        break;
      }

      case 'AddCredits':
        lines.push(`
  // ${stepId}: Add Credits
  const creditsTx = TxBody.addCredits({
    recipient: '${config.recipient ?? '${KEY_PAGE_URL}'}',
    amount: '${config.amount ?? '1000000'}',
  });
  const creditsResult = await client.submitAndWait(creditsTx, signer);
  results['${stepId}'] = creditsResult;`);
        break;

      default:
        lines.push(`
  // ${stepId}: ${node.type}
  // TODO: Implement ${node.type}
  results['${stepId}'] = { status: 'not_implemented' };`);
    }
  }

  return lines.join('\n');
}

function generateJavaScriptReadme(flow: Flow, safeName: string): string {
  return `# ${flow.name}

${flow.description ?? 'Generated by Accumulate Studio'}

## Installation

\`\`\`bash
npm install
\`\`\`

## Environment Variables

${flow.variables.map((v) => `- \`${v.name.toUpperCase()}\`: ${v.description ?? v.type}${v.required === false ? ' (optional)' : ''}`).join('\n') || 'No environment variables required.'}

## Usage

\`\`\`bash
npm start
\`\`\`

## Generated by Accumulate Studio

This project was automatically generated from a visual flow definition.
`;
}

// =============================================================================
// C# Project Generator
// =============================================================================

export function generateCSharpProject(flow: Flow): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const safeName = toPascalCase(flow.name);

  // Program.csproj
  files.push({
    path: `${safeName}.csproj`,
    content: `<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <RootNamespace>${safeName}</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Acme.Net.Sdk" Version="0.1.0" />
    <PackageReference Include="YamlDotNet" Version="15.1.0" />
  </ItemGroup>

</Project>
`,
  });

  // Program.cs
  files.push({
    path: 'Program.cs',
    content: generateCSharpMain(flow, safeName),
    isEntryPoint: true,
  });

  // README.md
  files.push({
    path: 'README.md',
    content: generateCSharpReadme(flow, safeName),
  });

  return files;
}

function generateCSharpMain(flow: Flow, namespace: string): string {
  const variableLoading = flow.variables
    .map((v) => {
      const envName = v.name.toUpperCase();
      const varName = toCamelCase(v.name);
      if (v.required !== false) {
        return `        var ${varName} = Environment.GetEnvironmentVariable("${envName}")
            ?? throw new InvalidOperationException("Missing required env var: ${envName}");`;
      }
      const defaultVal = v.default !== undefined ? `"${v.default}"` : '""';
      return `        var ${varName} = Environment.GetEnvironmentVariable("${envName}") ?? ${defaultVal};`;
    })
    .join('\n');

  return `/// <summary>
/// ${flow.name}
/// ${flow.description ?? 'Generated by Accumulate Studio'}
/// </summary>

using Acme.Net.Sdk;
using Acme.Net.Sdk.Protocol;
using Acme.Net.Sdk.Signing;
using Acme.Net.Sdk.Transactions;
using Acme.Net.Sdk.Helpers;

namespace ${namespace};

class Program
{
    static async Task Main(string[] args)
    {
        var results = await RunFlowAsync();
        Console.WriteLine("Flow completed successfully!");
    }

    static async Task<Dictionary<string, object>> RunFlowAsync()
    {
        // Load variables from environment
${variableLoading || '        // No variables defined'}

        // Initialize client
        var client = Accumulate.${toPascalCase(flow.network ?? 'testnet')}();

        // Results storage
        var results = new Dictionary<string, object>();

        // Execute flow blocks
${generateCSharpBlockExecution(flow)}

        return results;
    }
}
`;
}

function generateCSharpBlockExecution(flow: Flow): string {
  const lines: string[] = [];

  for (const node of flow.nodes) {
    const config = node.config as Record<string, unknown>;
    const stepId = node.id;

    switch (node.type) {
      case 'GenerateKeys':
        lines.push(`
        // ${stepId}: Generate Keys
        var keypair = Accumulate.GenerateEd25519Keypair();
        results["${stepId}"] = new { keypair.PublicKey, keypair.PublicKeyHash };`);
        break;

      case 'Faucet':
        lines.push(`
        // ${stepId}: Request from faucet
        var faucetResult = await client.FaucetAsync("${config.account ?? '${LITE_ACCOUNT}'}");
        results["${stepId}"] = faucetResult;`);
        break;

      case 'CreateIdentity':
        lines.push(`
        // ${stepId}: Create ADI
        var tx = TxBody.CreateIdentity(
            url: "${config.url ?? '${ADI_URL}'}",
            publicKeyHash: "${config.publicKeyHash ?? '${PUBLIC_KEY_HASH}'}"
        );
        var result = await client.SubmitAndWaitAsync(tx, signer);
        results["${stepId}"] = result;`);
        break;

      case 'CreateTokenAccount':
        lines.push(`
        // ${stepId}: Create Token Account
        var createTaTx = TxBody.CreateTokenAccount(
            url: "${config.url ?? '${TOKEN_ACCOUNT_URL}'}",
            tokenUrl: "${config.tokenUrl ?? 'acc://ACME'}"
        );
        var createTaResult = await client.SubmitAndWaitAsync(createTaTx, signer);
        results["${stepId}"] = createTaResult;`);
        break;

      case 'SendTokens': {
        const csRecipients = (config.recipients as Array<{ url: string; amount: string }>) ?? [];
        const csRecipStr = csRecipients
          .map((r) => `new { Url = "${r.url}", Amount = "${r.amount}" }`)
          .join(', ');
        lines.push(`
        // ${stepId}: Send Tokens
        var sendTx = TxBody.SendTokens(
            recipients: new[] { ${csRecipStr} }
        );
        var sendResult = await client.SubmitAndWaitAsync(sendTx, signer);
        results["${stepId}"] = sendResult;`);
        break;
      }

      case 'AddCredits':
        lines.push(`
        // ${stepId}: Add Credits
        var creditsTx = TxBody.AddCredits(
            recipient: "${config.recipient ?? '${KEY_PAGE_URL}'}",
            amount: "${config.amount ?? '1000000'}"
        );
        var creditsResult = await client.SubmitAndWaitAsync(creditsTx, signer);
        results["${stepId}"] = creditsResult;`);
        break;

      default:
        lines.push(`
        // ${stepId}: ${node.type}
        // TODO: Implement ${node.type}
        results["${stepId}"] = new { Status = "not_implemented" };`);
    }
  }

  return lines.join('\n');
}

function generateCSharpReadme(flow: Flow, safeName: string): string {
  return `# ${flow.name}

${flow.description ?? 'Generated by Accumulate Studio'}

## Build

\`\`\`bash
dotnet build
\`\`\`

## Environment Variables

${flow.variables.map((v) => `- \`${v.name.toUpperCase()}\`: ${v.description ?? v.type}${v.required === false ? ' (optional)' : ''}`).join('\n') || 'No environment variables required.'}

## Usage

\`\`\`bash
dotnet run
\`\`\`

## Generated by Accumulate Studio

This project was automatically generated from a visual flow definition.
`;
}

// =============================================================================
// Utility Functions
// =============================================================================

function toSnakeCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]/g, '_')
    .replace(/([A-Z])/g, '_$1')
    .toLowerCase()
    .replace(/^_/, '')
    .replace(/_+/g, '_');
}

function toKebabCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]/g, '-')
    .replace(/([A-Z])/g, '-$1')
    .toLowerCase()
    .replace(/^-/, '')
    .replace(/-+/g, '-');
}

function toCamelCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]/g, '_')
    .split('_')
    .map((word, index) =>
      index === 0 ? word.toLowerCase() : word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    )
    .join('');
}

function toPascalCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]/g, '_')
    .split('_')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

// =============================================================================
// Generator Registry
// =============================================================================

export const PROJECT_GENERATORS: Record<SDKLanguage, ProjectGenerator> = {
  python: generatePythonProject,
  rust: generateRustProject,
  dart: generateDartProject,
  javascript: generateJavaScriptProject,
  typescript: generateJavaScriptProject, // TypeScript uses same generator with type annotations
  csharp: generateCSharpProject,
};

/**
 * Generate a project for the specified language
 */
export function generateProject(flow: Flow, language: SDKLanguage): GeneratedFile[] {
  const generator = PROJECT_GENERATORS[language];
  if (!generator) {
    throw new Error(`No project generator available for language: ${language}`);
  }
  return generator(flow);
}
